use std::mem;

use crate::basis::Basis;
use crate::origin::Origin;
use crate::wheel::Wheel;

/// There are three kinds of primes produced by this sieve as it iterates:
/// - basis primes
///   - smallest primes below origin
///   - memorized
///   - used to determine the sieving wheel
/// - origin primes
///   - above basis and below sqrt(end)
///   - calculated and permanently stored during initialization
///   - used to strike wheel segments above sqrt(end)
/// - wheel primes
///   - above sqrt(end) and below end
///   - generated by sieving segments with origin primes
///   - discarded after iteration
///
/// The sieve exhibits different behavior while iterating through each of these kinds of primes,
/// so we enforce correct computation with a finite state machine:
///     Basis -> Origin -> Wheel -> Done
///                        ^___|
///
/// As a result, we can transparently get a single iterator through all primes, while ensuring
/// mutable state is managed safely.
///
/// Note that we decided *not* to directly make Sieve an enum because that would expose private
/// implementation details (i.e., the sieve states). Rust considers pub enum variants to be pub.
pub enum SieveStateMachine {
    Basis(Basis),
    Origin(Origin),
    Wheel(Wheel),
    Done,
}

impl Iterator for SieveStateMachine {
    type Item = usize;

    /// Return the next prime in the sieve, if possible.
    fn next(&mut self) -> Option<Self::Item> {
        use SieveStateMachine::*;

        match self {
            Basis(ref mut state) => state.next(),
            Origin(ref mut state) => state.next(),
            Wheel(ref mut state) => state.next(),
            Done => None,
        }
    }
}

impl SieveStateMachine {
    /// All new SieveStateMachines must start from a Basis state.
    pub fn new(start: usize, end: usize) -> SieveStateMachine {
        SieveStateMachine::Basis(Basis::new(start, end))
    }

    /// Step the state machine in place (consuming the previous state without moving it).
    ///
    /// We have to mem swap a temporary state machine because callers to step only have a
    /// mutable reference to self.
    pub fn step(&mut self) {
        use SieveStateMachine::*;

        let mut next = Done;
        mem::swap(self, &mut next);
        next = match next {
            Basis(state) => Origin(state.into()),
            Origin(state) => Wheel(state.into()),
            Wheel(state) if !state.done() => Wheel(state.advance_segment()),
            Wheel(_) | Done => Done,
        };
        mem::swap(self, &mut next);
    }
}
